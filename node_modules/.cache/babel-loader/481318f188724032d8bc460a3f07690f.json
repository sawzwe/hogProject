{"ast":null,"code":"import { animateStyle } from './animate-style.es.js';\nimport { getOptions } from './utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { withControls } from './utils/controls.es.js';\nimport { resolveOption } from '../utils/stagger.es.js';\nfunction animate(elements, keyframes) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  elements = resolveElements(elements);\n  const numElements = elements.length;\n  /**\n   * Create and start new animations\n   */\n  const animationFactories = [];\n  for (let i = 0; i < numElements; i++) {\n    const element = elements[i];\n    for (const key in keyframes) {\n      const valueOptions = getOptions(options, key);\n      valueOptions.delay = resolveOption(valueOptions.delay, i, numElements);\n      const animation = animateStyle(element, key, keyframes[key], valueOptions);\n      animationFactories.push(animation);\n    }\n  }\n  return withControls(animationFactories, options,\n  /**\n   * TODO:\n   * If easing is set to spring or glide, duration will be dynamically\n   * generated. Ideally we would dynamically generate this from\n   * animation.effect.getComputedTiming().duration but this isn't\n   * supported in iOS13 or our number polyfill. Perhaps it's possible\n   * to Proxy animations returned from animateStyle that has duration\n   * as a getter.\n   */\n  options.duration);\n}\nexport { animate };","map":null,"metadata":{},"sourceType":"module"}