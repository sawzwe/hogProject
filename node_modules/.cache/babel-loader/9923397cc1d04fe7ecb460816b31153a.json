{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { unstable_useForkRef as useForkRef, unstable_useId as useId } from '@mui/utils';\nimport { ActionTypes } from './useListbox.types';\nimport defaultReducer from './defaultListboxReducer';\nimport useControllableReducer from './useControllableReducer';\nimport areArraysEqual from '../utils/areArraysEqual';\nconst TEXT_NAVIGATION_RESET_TIMEOUT = 500; // milliseconds\n\nconst defaultOptionComparer = (optionA, optionB) => optionA === optionB;\nconst defaultIsOptionDisabled = () => false;\nconst defaultOptionStringifier = option => typeof option === 'string' ? option : String(option);\nexport default function useListbox(props) {\n  var _props$optionIdGenera, _options$highlightedI;\n  const {\n    disabledItemsFocusable = false,\n    disableListWrap = false,\n    focusManagement = 'activeDescendant',\n    id: idProp,\n    isOptionDisabled = defaultIsOptionDisabled,\n    listboxRef: externalListboxRef,\n    multiple = false,\n    optionComparer = defaultOptionComparer,\n    optionStringifier = defaultOptionStringifier,\n    options,\n    stateReducer: externalReducer\n  } = props;\n  const id = useId(idProp);\n  function defaultIdGenerator(_, index) {\n    return `${id}-option-${index}`;\n  }\n  const optionIdGenerator = (_props$optionIdGenera = props.optionIdGenerator) != null ? _props$optionIdGenera : defaultIdGenerator;\n  const propsWithDefaults = _extends({}, props, {\n    disabledItemsFocusable,\n    disableListWrap,\n    focusManagement,\n    isOptionDisabled,\n    multiple,\n    optionComparer,\n    optionStringifier\n  });\n  const listboxRef = React.useRef(null);\n  const handleRef = useForkRef(externalListboxRef, listboxRef);\n  const textCriteriaRef = React.useRef({\n    searchString: '',\n    lastTime: null\n  });\n  const [{\n    highlightedValue,\n    selectedValue\n  }, dispatch] = useControllableReducer(defaultReducer, externalReducer, propsWithDefaults);\n  const highlightedIndex = React.useMemo(() => {\n    return highlightedValue == null ? -1 : options.findIndex(option => optionComparer(option, highlightedValue));\n  }, [highlightedValue, options, optionComparer]);\n  const previousOptions = React.useRef([]);\n  React.useEffect(() => {\n    if (areArraysEqual(previousOptions.current, options, optionComparer)) {\n      return;\n    }\n    dispatch({\n      type: ActionTypes.optionsChange,\n      event: null,\n      options,\n      previousOptions: previousOptions.current,\n      props: propsWithDefaults\n    });\n    previousOptions.current = options; // No need to re-run this effect if props change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [options, optionComparer, dispatch]);\n  const setSelectedValue = React.useCallback(option => {\n    dispatch({\n      type: ActionTypes.setValue,\n      event: null,\n      value: option\n    });\n  }, [dispatch]);\n  const setHighlightedValue = React.useCallback(option => {\n    dispatch({\n      type: ActionTypes.setHighlight,\n      event: null,\n      highlight: option\n    });\n  }, [dispatch]);\n  const createHandleOptionClick = (option, other) => event => {\n    var _other$onClick;\n    (_other$onClick = other.onClick) == null ? void 0 : _other$onClick.call(other, event);\n    if (event.defaultPrevented) {\n      return;\n    }\n    event.preventDefault();\n    dispatch({\n      type: ActionTypes.optionClick,\n      option,\n      event,\n      props: propsWithDefaults\n    });\n  };\n  const createHandleOptionPointerOver = (option, other) => event => {\n    var _other$onMouseOver;\n    (_other$onMouseOver = other.onMouseOver) == null ? void 0 : _other$onMouseOver.call(other, event);\n    if (event.defaultPrevented) {\n      return;\n    }\n    dispatch({\n      type: ActionTypes.optionHover,\n      option,\n      event,\n      props: propsWithDefaults\n    });\n  };\n  const createHandleKeyDown = other => event => {\n    var _other$onKeyDown;\n    (_other$onKeyDown = other.onKeyDown) == null ? void 0 : _other$onKeyDown.call(other, event);\n    if (event.defaultPrevented) {\n      return;\n    }\n    const keysToPreventDefault = ['ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'];\n    if (focusManagement === 'activeDescendant') {\n      // When the child element is focused using the activeDescendant attribute,\n      // the listbox handles keyboard events on its behalf.\n      // We have to `preventDefault()` is this case to prevent the browser from\n      // scrolling the view when space is pressed or submitting forms when enter is pressed.\n      keysToPreventDefault.push(' ', 'Enter');\n    }\n    if (keysToPreventDefault.includes(event.key)) {\n      event.preventDefault();\n    }\n    dispatch({\n      type: ActionTypes.keyDown,\n      event,\n      props: propsWithDefaults\n    }); // Handle text navigation\n\n    if (event.key.length === 1 && event.key !== ' ') {\n      const textCriteria = textCriteriaRef.current;\n      const lowerKey = event.key.toLowerCase();\n      const currentTime = performance.now();\n      if (textCriteria.searchString.length > 0 && textCriteria.lastTime && currentTime - textCriteria.lastTime > TEXT_NAVIGATION_RESET_TIMEOUT) {\n        textCriteria.searchString = lowerKey;\n      } else if (textCriteria.searchString.length !== 1 || lowerKey !== textCriteria.searchString) {\n        // If there is just one character in the buffer and the key is the same, do not append\n        textCriteria.searchString += lowerKey;\n      }\n      textCriteria.lastTime = currentTime;\n      dispatch({\n        type: ActionTypes.textNavigation,\n        event,\n        searchString: textCriteria.searchString,\n        props: propsWithDefaults\n      });\n    }\n  };\n  const createHandleBlur = other => event => {\n    var _other$onBlur, _listboxRef$current;\n    (_other$onBlur = other.onBlur) == null ? void 0 : _other$onBlur.call(other, event);\n    if (event.defaultPrevented) {\n      return;\n    }\n    if ((_listboxRef$current = listboxRef.current) != null && _listboxRef$current.contains(document.activeElement)) {\n      // focus is within the listbox\n      return;\n    }\n    dispatch({\n      type: ActionTypes.blur,\n      event,\n      props: propsWithDefaults\n    });\n  };\n  const getRootProps = function () {\n    let otherHandlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return _extends({}, otherHandlers, {\n      'aria-activedescendant': focusManagement === 'activeDescendant' && highlightedValue != null ? optionIdGenerator(highlightedValue, highlightedIndex) : undefined,\n      id,\n      onBlur: createHandleBlur(otherHandlers),\n      onKeyDown: createHandleKeyDown(otherHandlers),\n      role: 'listbox',\n      tabIndex: focusManagement === 'DOM' ? -1 : 0,\n      ref: handleRef\n    });\n  };\n  const getOptionState = option => {\n    let selected;\n    const index = options.findIndex(opt => optionComparer(opt, option));\n    if (multiple) {\n      var _ref;\n      selected = ((_ref = selectedValue) != null ? _ref : []).some(value => value != null && optionComparer(option, value));\n    } else {\n      selected = optionComparer(option, selectedValue);\n    }\n    const disabled = isOptionDisabled(option, index);\n    return {\n      selected,\n      disabled,\n      highlighted: highlightedIndex === index\n    };\n  };\n  const getOptionTabIndex = optionState => {\n    if (focusManagement === 'activeDescendant') {\n      return undefined;\n    }\n    if (!optionState.highlighted) {\n      return -1;\n    }\n    if (optionState.disabled && !disabledItemsFocusable) {\n      return -1;\n    }\n    return 0;\n  };\n  const getOptionProps = function (option) {\n    let otherHandlers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const optionState = getOptionState(option);\n    const index = options.findIndex(opt => optionComparer(opt, option));\n    return _extends({}, otherHandlers, {\n      'aria-disabled': optionState.disabled || undefined,\n      'aria-selected': optionState.selected,\n      id: optionIdGenerator(option, index),\n      onClick: createHandleOptionClick(option, otherHandlers),\n      onPointerOver: createHandleOptionPointerOver(option, otherHandlers),\n      role: 'option',\n      tabIndex: getOptionTabIndex(optionState)\n    });\n  };\n  React.useDebugValue({\n    highlightedOption: options[highlightedIndex],\n    selectedOption: selectedValue\n  });\n  return {\n    getRootProps,\n    getOptionProps,\n    getOptionState,\n    highlightedOption: (_options$highlightedI = options[highlightedIndex]) != null ? _options$highlightedI : null,\n    selectedOption: selectedValue,\n    setSelectedValue,\n    setHighlightedValue\n  };\n}","map":null,"metadata":{},"sourceType":"module"}